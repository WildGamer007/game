<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labubu's Rebellion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js" onload="console.log('p5.js loaded')" onerror="console.error('Failed to load p5.js')"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js" onload="console.log('p5.sound.js loaded')" onerror="console.error('Failed to load p5.sound.js')"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #222; touch-action: none; }
    canvas { border: 2px solid #fff; }
    #settings { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); color: white; padding: 10px; }
    #settings input, #settings button { margin: 5px; }
    .hidden { display: none; }
    #touchControls { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-between; pointer-events: none; }
    #joystickContainer { position: relative; width: 100px; height: 100px; margin-left: 20px; pointer-events: auto; }
    #joystickBase { position: absolute; width: 100px; height: 100px; background: rgba(255, 255, 255, 0.3); border-radius: 50%; }
    #joystickHandle { position: absolute; width: 40px; height: 40px; background: rgba(255, 0, 0, 0.7); border-radius: 50%; }
    #attackButton, #switchAttackButton { pointer-events: auto; width: 60px; height: 60px; border-radius: 50%; margin-right: 20px; font-size: 16px; color: white; border: none; }
    #attackButton { background: rgba(0, 255, 0, 0.7); }
    #switchAttackButton { background: rgba(0, 0, 255, 0.7); }
  </style>
</head>
<body>
  <div id="settings">
    <label>Character Name: <input type="text" id="charName" value="Labubu"></label><br>
    <label>Unlimited Powers: <input type="checkbox" id="unlimitedPowers"></label><br>
    <label>Number of Lives (1-10): <input type="number" id="playerLives" value="3" min="1" max="10"></label><br>
    <button onclick="applySettings()">Apply Settings</button>
  </div>
  <div id="touchControls" class="hidden">
    <div id="joystickContainer">
      <div id="joystickBase"></div>
      <div id="joystickHandle"></div>
    </div>
    <div>
      <button id="attackButton">Attack</button>
      <button id="switchAttackButton">Switch</button>
    </div>
  </div>
<script>
let player, enemies, energyOrbs, level, energy, combo, gameState, boss, showHelp, attackTimer;
let bgImage = null, jumpSound = null, attackSound = null, enemyDieSound = null, bgMusic = null;
let characterName = "Labubu";
let unlimitedPowers = false;
let playerLives = 3;
let consoleMessages = [];
let maxConsoleMessages = 5;
let joystick = { active: false, x: 0, y: 0, baseX: 70, baseY: 530, handleX: 70, handleY: 530, radius: 50 };
let attackButtonPressed = false;
let attackTypes = ['hand', 'leg', 'voice', 'eye', 'thunder', 'missile'];
let currentAttackIndex = 0;

function preload() {
  try {
    bgImage = loadImage('war_image.png', 
      () => logToConsole("Background image loaded"),
      () => { console.error('Failed to load background image'); logToConsole("Background image failed to load"); }
    );
    if (typeof loadSound === 'function') {
      jumpSound = loadSound('button-09a.mp3', 
        () => logToConsole("Jump sound loaded"),
        () => { console.error('Failed to load jump sound'); logToConsole("Jump sound failed to load"); }
      );
      attackSound = loadSound('button-09a.mp3',
        () => logToConsole("Attack sound loaded"),
        () => { console.error('Failed to load attack sound'); logToConsole("Attack sound failed to load"); }
      );
      enemyDieSound = loadSound('bone-crack-1.mp3',
        () => logToConsole("Enemy death sound loaded"),
        () => { console.error('Failed to load enemy death sound'); logToConsole("Enemy death sound failed to load"); }
      );
      bgMusic = loadSound('war_bg_sound.mp3',
        () => logToConsole("Background music loaded"),
        () => { console.error('Failed to load background music'); logToConsole("Background music failed to load"); }
      );
    } else {
      console.error('p5.sound.js not loaded, sounds disabled');
      logToConsole("Sounds disabled: p5.sound.js not loaded");
    }
  } catch (e) {
    console.error('Error in preload:', e);
    logToConsole("Preload error occurred");
  }
}

function setup() {
  try {
    createCanvas(800, 600);
    resetGame();
    if (bgMusic && typeof bgMusic.loop === 'function') {
      bgMusic.loop();
      logToConsole("Background music started");
    }
    logToConsole("Game initialized");
    setupTouchControls();
  } catch (e) {
    console.error('Error in setup:', e);
    logToConsole("Setup error occurred");
  }
}

function setupTouchControls() {
  try {
    let attackButton = document.getElementById('attackButton');
    let switchAttackButton = document.getElementById('switchAttackButton');
    attackButton.addEventListener('touchstart', () => {
      attackButtonPressed = true;
      if (gameState === 'playing' && !player.attackActive && (unlimitedPowers || player.energy >= player.attacks[player.currentAttack])) {
        player.attackActive = true;
        player.attackFrame = 0;
        if (attackSound) attackSound.play();
        logToConsole(`${characterName} attacked with ${player.currentAttack}`);
      }
    });
    attackButton.addEventListener('touchend', () => attackButtonPressed = false);
    switchAttackButton.addEventListener('touchstart', () => {
      currentAttackIndex = (currentAttackIndex + 1) % attackTypes.length;
      player.currentAttack = attackTypes[currentAttackIndex];
      logToConsole(`Selected ${player.currentAttack} attack`);
    });
  } catch (e) {
    console.error('Error in setupTouchControls:', e);
    logToConsole("Touch controls setup error");
  }
}

function applySettings() {
  try {
    let oldName = characterName;
    characterName = document.getElementById('charName').value || "Labubu";
    unlimitedPowers = document.getElementById('unlimitedPowers').checked;
    let livesInput = parseInt(document.getElementById('playerLives').value);
    playerLives = isNaN(livesInput) ? 3 : constrain(livesInput, 1, 10);
    logToConsole(`Settings updated: Name=${characterName}, UnlimitedPowers=${unlimitedPowers}, Lives=${playerLives}`);
    if (oldName !== characterName) {
      logToConsole(`Character name changed from ${oldName} to ${characterName}`);
    }
    document.getElementById('settings').classList.add('hidden');
    document.getElementById('touchControls').classList.remove('hidden');
  } catch (e) {
    console.error('Error in applySettings:', e);
    logToConsole("Settings update error");
  }
}

function logToConsole(message) {
  consoleMessages.push(`${frameCount}: ${message}`);
  if (consoleMessages.length > maxConsoleMessages) {
    consoleMessages.shift();
  }
  console.log(message);
}

function resetGame() {
  try {
    player = {
      x: 50, y: 500, w: 13, h: 20, speed: 5, jump: -15, vy: 0, grounded: false,
      attacks: { hand: 10, leg: 15, voice: 20, eye: 25, thunder: 30, missile: 35 },
      currentAttack: 'hand', energy: 50, maxEnergy: 100, health: 100, lives: playerLives,
      attackActive: false, attackFrame: 0, missiles: []
    };
    enemies = [];
    energyOrbs = [];
    level = 1;
    energy = 0;
    combo = 0;
    gameState = 'start';
    boss = null;
    showHelp = false;
    attackTimer = 0;
    consoleMessages = [];
    currentAttackIndex = 0;
    document.getElementById('settings').classList.remove('hidden');
    document.getElementById('touchControls').classList.add('hidden');
    spawnEnemies();
    logToConsole("Game reset");
  } catch (e) {
    console.error('Error in resetGame:', e);
    logToConsole("Reset game error");
  }
}

function spawnEnemies() {
  try {
    enemies = [];
    let enemyTypes = [
      { type: 'human', health: 20, speed: 1, damage: 5, w: 15, h: 25 },
      { type: 'military', health: 40, speed: 0.75, damage: 10, w: 15, h: 25 },
      { type: 'terrorist', health: 30, speed: 1.25, damage: 15, w: 15, h: 25 },
      { type: 'virus', health: 10, speed: 1.5, damage: 5, w: 7.5, h: 7.5 },
      { type: 'missile', health: 15, speed: 2, damage: 20, w: 10, h: 5 }
    ];
    let count = level * 3;
    if (level === 10) {
      boss = {
        x: 700, y: 500, w: 30, h: 40, health: 500, maxHealth: 500, speed: 0.5,
        attacks: ['electric', 'f16', 'missile', 'covid', 'military', 'terrorist', 'zelensky'],
        attackCooldown: 0, minions: []
      };
      enemies.push(boss);
      logToConsole("Boss spawned");
    } else {
      for (let i = 0; i < count; i++) {
        let type = random(enemyTypes);
        enemies.push({ x: random(400, 750), y: 500, ...type });
      }
      logToConsole(`Spawned ${count} enemies for level ${level}`);
    }
  } catch (e) {
    console.error('Error in spawnEnemies:', e);
    logToConsole("Spawn enemies error");
  }
}

function draw() {
  try {
    if (bgImage) {
      image(bgImage, 0, 0, width, height);
    } else {
      background(50);
    }
    if (gameState === 'start') {
      drawStartScreen();
    } else if (gameState === 'playing') {
      updatePlayer();
      updateEnemies();
      updateEnergyOrbs();
      handleCollisions();
      drawUI();
      if (showHelp) drawHelpScreen();
      drawConsole();
      updateJoystick();
    } else if (gameState === 'gameover') {
      textSize(32);
      fill(255, 0, 0);
      textAlign(CENTER);
      text('Game Over! Press R or Tap to Restart', width / 2, height / 2);
    } else if (gameState === 'win') {
      textSize(32);
      fill(0, 255, 0);
      textAlign(CENTER);
      text('You Win! Press R or Tap to Restart', width / 2, height / 2);
    }
  } catch (e) {
    console.error('Error in draw:', e);
    logToConsole("Draw error occurred");
  }
}

function drawConsole() {
  try {
    fill(0, 0, 0, 200);
    rect(width - 200, height - 120, 190, 110);
    fill(255);
    textAlign(LEFT);
    textSize(12);
    for (let i = 0; i < consoleMessages.length; i++) {
      text(consoleMessages[i], width - 195, height - 100 + i * 20);
    }
  } catch (e) {
    console.error('Error in drawConsole:', e);
  }
}

function drawStartScreen() {
  try {
    fill(255);
    rect(55, 100, 650, 400);
    fill(0);
    textStyle(BOLD);
    textAlign(CENTER);
    textSize(32);
    text(`${characterName}'s Rebellion`, width / 2, height / 2 - 100);
    textSize(20);
    text("Controls:", width / 2, height / 2 - 50);
    text("Left/Right Arrows or Joystick: Move", width / 2, height / 2 - 20);
    text("Up Arrow or Joystick Up: Jump", width / 2, height / 2 + 10);
    text("Spacebar or Attack Button: Attack", width / 2, height / 2 + 40);
    text("1-6 or Switch Button: Change Attack", width / 2, height / 2 + 70);
    text("H: Show/Hide Help", width / 2, height / 2 + 100);
    text("R or Tap: Restart (on Game Over/Win)", width / 2, height / 2 + 130);
    text("Press S or Tap to Start", width / 2, height / 2 + 160);
  } catch (e) {
    console.error('Error in drawStartScreen:', e);
    logToConsole("Start screen error");
  }
}

function drawHelpScreen() {
  try {
    fill(0, 0, 0, 200);
    rect(55, 100, 650, 400);
    fill(255);
    rect(55, 120, 650, 260);
    fill(0);
    textAlign(CENTER);
    textSize(24);
    text("Controls", width / 2, 150);
    textSize(18);
    text("Left/Right Arrows or Joystick: Move", width / 2, 200);
    text("Up Arrow or Joystick Up: Jump", width / 2, 230);
    text("Spacebar or Attack Button: Attack", width / 2, 260);
    text("1-6 or Switch Button: Change Attack (Hand:10, Leg:15, Voice:20, Eye:25, Thunder:30, Missile:35)", width / 2, 290);
    text("H: Show/Hide Help", width / 2, 320);
    text("R or Tap: Restart (on Game Over/Win)", width / 2, 350);
    text("Press H to Close", width / 2, 380);
  } catch (e) {
    console.error('Error in drawHelpScreen:', e);
    logToConsole("Help screen error");
  }
}

function updatePlayer() {
  try {
    if (joystick.active) {
      let dx = joystick.x - joystick.baseX;
      let dy = joystick.y - joystick.baseY;
      let mag = Math.sqrt(dx * dx + dy * dy);
      if (mag > 10) {
        let angle = Math.atan2(dy, dx);
        let moveSpeed = Math.min(mag / joystick.radius, 1) * player.speed;
        player.x += Math.cos(angle) * moveSpeed;
        if (Math.cos(angle) < -0.5) logToConsole(`${characterName} moved left`);
        if (Math.cos(angle) > 0.5) logToConsole(`${characterName} moved right`);
        if (Math.sin(angle) < -0.5 && player.grounded) {
          player.vy = player.jump;
          player.grounded = false;
          if (jumpSound) jumpSound.play();
          logToConsole(`${characterName} jumped`);
        }
      }
    } else {
      if (keyIsDown(LEFT_ARROW)) {
        player.x -= player.speed;
        logToConsole(`${characterName} moved left`);
      }
      if (keyIsDown(RIGHT_ARROW)) {
        player.x += player.speed;
        logToConsole(`${characterName} moved right`);
      }
      if (keyIsDown(UP_ARROW) && player.grounded) {
        player.vy = player.jump;
        player.grounded = false;
        if (jumpSound) jumpSound.play();
        logToConsole(`${characterName} jumped`);
      }
    }
    player.vy += 0.5;
    player.y += player.vy;
    if (player.y >= 500) {
      player.y = 500;
      player.vy = 0;
      player.grounded = true;
    }
    player.x = constrain(player.x, 0, width - player.w);

    if (player.attackActive) {
      player.attackFrame++;
      if (player.attackFrame > 10) {
        player.attackActive = false;
        player.attackFrame = 0;
      }
    }

    for (let i = player.missiles.length - 1; i >= 0; i--) {
      let m = player.missiles[i];
      m.x += m.speed;
      if (m.x > width) {
        player.missiles.splice(i, 1);
      }
    }

    fill(255, 0, 0);
    rect(player.x, player.y - 5, player.w, 5, 2); // Hat
    fill(255);
    ellipse(player.x + player.w / 2, player.y + 6, 10, 7); // Face
    fill(0);
    ellipse(player.x + 4, player.y + 4, 2, 3); // Eyes
    ellipse(player.x + 9, player.y + 4, 2, 3);
    noFill();
    stroke(0);
    arc(player.x + player.w / 2, player.y + 8, 4, 2, 0, PI); // Mouth
    noStroke();
    fill(0, 0, 255);
    rect(player.x, player.y + 5, player.w, player.h - 10); // Body
    fill(255, 0, 0);
    rect(player.x, player.y + 10, player.w, 5); // Shirt
    fill(255);
    if (player.attackActive && player.currentAttack === 'hand') {
      ellipse(player.x + player.w + 24, player.y + 7, 24, 24);
      ellipse(player.x - 3, player.y + 7, 3, 3);
    } else {
      ellipse(player.x + player.w, player.y + 7, 24, 24);
      ellipse(player.x, player.y + 7, 3, 3);
    }
    fill(139, 69, 19);
    if (player.attackActive && player.currentAttack === 'leg') {
      rect(player.x + 2, player.y + player.h, 4, 7);
      rect(player.x + 7, player.y + player.h, 4, 7);
    } else {
      rect(player.x + 2, player.y + player.h, 4, 4);
      rect(player.x + 7, player.y + player.h, 4, 4);
    }
    if (player.attackActive) {
      if (player.currentAttack === 'voice') {
        fill(255, 255, 0, 150);
        arc(player.x + player.w / 2, player.y + 8, 34, 20, 0, HALF_PI);
      } else if (player.currentAttack === 'eye') {
        stroke(255, 0, 0);
        line(player.x + 4, player.y + 4, player.x + 105, player.y + 4);
        line(player.x + 9, player.y + 4, player.x + 130, player.y + 4);
        noStroke();
      } else if (player.currentAttack === 'thunder') {
        fill(0, 255, 255, 150);
        ellipse(player.x + player.w / 2, player.y, 20, 20);
      } else if (player.currentAttack === 'missile') {
        player.missiles.push({ x: player.x + player.w, y: player.y, speed: 5, damage: 35 });
      }
    }
    fill(255, 0, 0);
    for (let m of player.missiles) {
      rect(m.x, m.y, 10, 5);
    }
  } catch (e) {
    console.error('Error in updatePlayer:', e);
    logToConsole("Player update error");
  }
}

function updateEnemies() {
  try {
    for (let i = enemies.length - 1; i >= 0; i--) {
      let e = enemies[i];
      if (e.type === 'missile' || e.type === 'virus') {
        e.x -= e.speed;
      } else {
        if (player.x < e.x) e.x -= e.speed;
        else if (player.x > e.x) e.x += e.speed;
      }
      e.x = constrain(e.x, 0, width - e.w);

      if (e === boss) {
        e.attackCooldown--;
        if (e.attackCooldown <= 0) {
          let attack = random(e.attacks);
          if (attack === 'electric') {
            enemies.push({ x: e.x, y: e.y, w: 25, h: 5, type: 'electric', health: 10, speed: 2.5, damage: 20 });
            logToConsole("Boss used electric attack");
          } else if (attack === 'f16') {
            e.minions.push({ x: 800, y: 100, w: 20, h: 10, type: 'f16', health: 30, speed: 1.5, damage: 15 });
            logToConsole("Boss spawned F16 minion");
          } else if (attack === 'missile') {
            enemies.push({ x: e.x, y: e.y, w: 10, h: 5, type: 'missile', health: 15, speed: 2, damage: 20 });
            logToConsole("Boss used missile attack");
          } else if (attack === 'covid') {
            enemies.push({ x: e.x, y: e.y, w: 7.5, h: 7.5, type: 'virus', health: 10, speed: 1.5, damage: 5 });
            logToConsole("Boss used covid attack");
          } else if (attack === 'military' || attack === 'terrorist') {
            e.minions.push({ x: e.x, y: e.y, w: 15, h: 25, type: attack, health: 30, speed: 1, damage: 10 });
            logToConsole(`Boss spawned ${attack} minion`);
          } else if (attack === 'zelensky') {
            e.minions.push({ x: e.x, y: e.y, w: 15, h: 25, type: 'zelensky', health: 50, speed: 1.25, damage: 15 });
            logToConsole("Boss spawned Zelensky minion");
          }
          e.attackCooldown = 60;
        }
        for (let j = e.minions.length - 1; j >= 0; j--) {
          let m = e.minions[j];
          if (m.type === 'f16') {
            m.x -= m.speed;
          } else {
            if (player.x < m.x) m.x -= m.speed;
            else if (player.x > m.x) m.x += m.speed;
          }
          if (m.type === 'f16') {
            fill(150);
            rect(m.x, m.y, m.w, m.h);
          } else {
            fill(m.type === 'zelensky' ? 0 : 100);
            ellipse(m.x + m.w / 2, m.y - 5, 8, 8);
            rect(m.x, m.y, m.w, m.h - 5);
            fill(255);
            ellipse(m.x + m.w, m.y + 5, 3, 3);
            ellipse(m.x, m.y + 5, 3, 3);
            fill(100);
            rect(m.x + 2, m.y + m.h - 5, 4, 5);
            rect(m.x + m.w - 6, m.y + m.h - 5, 4, 5);
          }
        }
      }

      if (e.type === 'missile' || e.type === 'virus' || e.type === 'electric') {
        fill(e.type === 'virus' ? 0 : e.type === 'electric' ? 255 : 255);
        rect(e.x, e.y, e.w, e.h);
      } else {
        fill(e.type === 'human' ? 200 : e.type === 'military' ? 100 : e.type === 'terrorist' ? 150 : 100);
        ellipse(e.x + e.w / 2, e.y - 5, 8, 8);
        rect(e.x, e.y, e.w, e.h - 5);
        fill(255);
        ellipse(e.x + e.w, e.y + 5, 3, 3);
        ellipse(e.x, e.y + 5, 3, 3);
        fill(100);
        rect(e.x + 2, e.y + e.h - 5, 4, 5);
        rect(e.x + e.w - 6, e.y + e.h - 5, 4, 5);
      }
    }
  } catch (e) {
    console.error('Error in updateEnemies:', e);
    logToConsole("Update enemies error");
  }
}

function updateEnergyOrbs() {
  try {
    for (let orb of energyOrbs) {
      orb.y += 2;
      fill(255, 255, 0);
      ellipse(orb.x, orb.y, 10, 10);
    }
  } catch (e) {
    console.error('Error in updateEnergyOrbs:', e);
    logToConsole("Energy orbs update error");
  }
}

function handleCollisions() {
  try {
    if (player.attackActive) {
      let attackRange = player.currentAttack === 'hand' ? 34 : 17;
      for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        if (player.currentAttack === 'missile') {
          for (let j = player.missiles.length - 1; j >= 0; j--) {
            let m = player.missiles[j];
            if (collideRectRect(m.x, m.y, 10, 5, e.x, e.y, e.w, e.h)) {
              e.health -= m.damage;
              player.missiles.splice(j, 1);
              if (e.health <= 0) {
                enemies.splice(i, 1);
                energyOrbs.push({ x: e.x, y: e.y });
                if (enemyDieSound) enemyDieSound.play();
                logToConsole(`Enemy (${e.type}) defeated by missile`);
                if (!unlimitedPowers) player.energy = min(player.energy + 5, player.maxEnergy);
              }
            }
          }
        } else if (collideRectRect(player.x + player.w / 2 - attackRange / 2, player.y, attackRange, player.h, e.x, e.y, e.w, e.h)) {
          e.health -= player.attacks[player.currentAttack];
          if (!unlimitedPowers) player.energy -= player.attacks[player.currentAttack];
          combo++;
          if (e.health <= 0) {
            enemies.splice(i, 1);
            energyOrbs.push({ x: e.x, y: e.y });
            if (enemyDieSound) enemyDieSound.play();
            logToConsole(`Enemy (${e.type}) defeated`);
            if (!unlimitedPowers) player.energy = min(player.energy + 5, player.maxEnergy);
          }
        }
      }
      if (boss) {
        for (let i = boss.minions.length - 1; i >= 0; i--) {
          let m = boss.minions[i];
          if (player.currentAttack === 'missile') {
            for (let j = player.missiles.length - 1; j >= 0; j--) {
              let pm = player.missiles[j];
              if (collideRectRect(pm.x, pm.y, 10, 5, m.x, m.y, m.w, m.h)) {
                m.health -= pm.damage;
                player.missiles.splice(j, 1);
                if (m.health <= 0) {
                  boss.minions.splice(i, 1);
                  if (enemyDieSound) enemyDieSound.play();
                  logToConsole(`Boss minion (${m.type}) defeated by missile`);
                  if (!unlimitedPowers) player.energy = min(player.energy + 5, player.maxEnergy);
                }
              }
            }
          } else if (collideRectRect(player.x + player.w / 2 - attackRange / 2, player.y, attackRange, player.h, m.x, m.y, m.w, m.h)) {
            m.health -= player.attacks[player.currentAttack];
            if (!unlimitedPowers) player.energy -= player.attacks[player.currentAttack];
            combo++;
            if (m.health <= 0) {
              boss.minions.splice(i, 1);
              if (enemyDieSound) enemyDieSound.play();
              logToConsole(`Boss minion (${m.type}) defeated`);
              if (!unlimitedPowers) player.energy = min(player.energy + 5, player.maxEnergy);
            }
          }
        }
      }
    }

    for (let e of enemies) {
      if (collideRectRect(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
        player.health -= e.damage;
        logToConsole(`${characterName} took ${e.damage} damage from ${e.type}`);
        if (player.health <= 0) {
          player.lives--;
          logToConsole(`${characterName} lost a life, ${player.lives} remaining`);
          if (player.lives <= 0) {
            gameState = 'gameover';
            logToConsole("Game over");
          } else {
            player.health = 100;
            player.x = 50;
            player.y = 500;
            player.vy = 0;
            player.grounded = true;
            logToConsole(`${characterName} respawned`);
          }
        }
      }
    }
    if (boss) {
      for (let m of boss.minions) {
        if (collideRectRect(player.x, player.y, player.w, player.h, m.x, m.y, m.w, m.h)) {
          player.health -= m.damage;
          logToConsole(`${characterName} took ${m.damage} damage from boss minion ${m.type}`);
          if (player.health <= 0) {
            player.lives--;
            logToConsole(`${characterName} lost a life, ${player.lives} remaining`);
            if (player.lives <= 0) {
              gameState = 'gameover';
              logToConsole("Game over");
            } else {
              player.health = 100;
              player.x = 50;
              player.y = 500;
              player.vy = 0;
              player.grounded = true;
              logToConsole(`${characterName} respawned`);
            }
          }
        }
      }
    }

    for (let i = energyOrbs.length - 1; i >= 0; i--) {
      let orb = energyOrbs[i];
      if (dist(player.x + player.w / 2, player.y + player.h / 2, orb.x, orb.y) < 7) {
        player.energy = min(player.energy + 10, player.maxEnergy);
        energyOrbs.splice(i, 1);
        logToConsole(`${characterName} collected energy orb`);
      }
    }

    if (enemies.length === 0 && (!boss || (boss && boss.health <= 0 && boss.minions.length === 0))) {
      if (level < 10) {
        level++;
        spawnEnemies();
        logToConsole(`Advanced to level ${level}`);
      } else {
        gameState = 'win';
        logToConsole("Game won");
      }
    }
  } catch (e) {
    console.error('Error in handleCollisions:', e);
    logToConsole("Collisions error");
  }
}

function drawUI() {
  try {
    fill(255);
    textSize(20);
    text(`Name: ${characterName}`, 10, 30);
    text(`Health: ${player.health}`, 10, 50);
    text(`Lives: ${player.lives}`, 10, 70);
    text(`Energy: ${player.energy}`, 10, 90);
    text(`Level: ${level}`, 10, 110);
    text(`Combo: ${combo}`, 10, 130);
    text(`Attack: ${player.currentAttack}`, 10, 150);
    text('Switch: Change Attack', 10, 170);
    text('H: Help', 10, 190);
    if (boss) {
      fill(255, 0, 0);
      rect(600, 20, map(boss.health, 0, boss.maxHealth, 0, 180), 20);
      fill(255);
      text('Boss Health', 520, 35);
    }
  } catch (e) {
    console.error('Error in drawUI:', e);
    logToConsole("UI draw error");
  }
}

function keyPressed() {
  try {
    if (key === 's' && gameState === 'start') {
      gameState = 'playing';
      logToConsole("Game started");
    }
    if (key === 'h' && gameState === 'playing') {
      showHelp = !showHelp;
      logToConsole(`Help screen ${showHelp ? 'shown' : 'hidden'}`);
    }
    if (key === '1') {
      player.currentAttack = 'hand';
      currentAttackIndex = 0;
      logToConsole("Selected hand attack");
    }
    if (key === '2') {
      player.currentAttack = 'leg';
      currentAttackIndex = 1;
      logToConsole("Selected leg attack");
    }
    if (key === '3') {
      player.currentAttack = 'voice';
      currentAttackIndex = 2;
      logToConsole("Selected voice attack");
    }
    if (key === '4') {
      player.currentAttack = 'eye';
      currentAttackIndex = 3;
      logToConsole("Selected eye attack");
    }
    if (key === '5') {
      player.currentAttack = 'thunder';
      currentAttackIndex = 4;
      logToConsole("Selected thunder attack");
    }
    if (key === '6') {
      player.currentAttack = 'missile';
      currentAttackIndex = 5;
      logToConsole("Selected missile attack");
    }
    if (key === 'r' && (gameState === 'gameover' || gameState === 'win')) {
      resetGame();
      logToConsole("Game restarted");
    }
    if (keyCode === 32 && gameState === 'playing' && !player.attackActive && (unlimitedPowers || player.energy >= player.attacks[player.currentAttack])) {
      player.attackActive = true;
      player.attackFrame = 0;
      if (attackSound) attackSound.play();
      logToConsole(`${characterName} attacked with ${player.currentAttack}`);
    }
  } catch (e) {
    console.error('Error in keyPressed:', e);
    logToConsole("Key press error");
  }
}

function touchStarted() {
  try {
    if (gameState === 'start') {
      gameState = 'playing';
      logToConsole("Game started via touch");
      return false;
    }
    if (gameState === 'gameover' || gameState === 'win') {
      resetGame();
      logToConsole("Game restarted via touch");
      return false;
    }
    for (let touch of touches) {
      let tx = touch.x;
      let ty = touch.y;
      if (dist(tx, ty, joystick.baseX, joystick.baseY) < joystick.radius) {
        joystick.active = true;
        joystick.x = tx;
        joystick.y = ty;
        updateJoystick();
      }
    }
    return false;
  } catch (e) {
    console.error('Error in touchStarted:', e);
    logToConsole("Touch start error");
    return false;
  }
}

function touchMoved() {
  try {
    for (let touch of touches) {
      let tx = touch.x;
      let ty = touch.y;
      if (joystick.active && dist(tx, ty, joystick.baseX, joystick.baseY) < joystick.radius * 2) {
        joystick.x = tx;
        joystick.y = ty;
        updateJoystick();
      }
    }
    return false;
  } catch (e) {
    console.error('Error in touchMoved:', e);
    logToConsole("Touch move error");
    return false;
  }
}

function touchEnded() {
  try {
    joystick.active = false;
    updateJoystick();
    return false;
  } catch (e) {
    console.error('Error in touchEnded:', e);
    logToConsole("Touch end error");
    return false;
  }
}

function updateJoystick() {
  try {
    let handle = document.getElementById('joystickHandle');
    if (joystick.active) {
      let dx = joystick.x - joystick.baseX;
      let dy = joystick.y - joystick.baseY;
      let mag = Math.sqrt(dx * dx + dy * dy);
      let angle = Math.atan2(dy, dx);
      if (mag > joystick.radius) {
        joystick.x = joystick.baseX + Math.cos(angle) * joystick.radius;
        joystick.y = joystick.baseY + Math.sin(angle) * joystick.radius;
      }
      handle.style.left = (joystick.x - 20) + 'px';
      handle.style.top = (joystick.y - 20) + 'px';
    } else {
      joystick.x = joystick.baseX;
      joystick.y = joystick.baseY;
      handle.style.left = (joystick.baseX - 20) + 'px';
      handle.style.top = (joystick.baseY - 20) + 'px';
    }
  } catch (e) {
    console.error('Error in updateJoystick:', e);
    logToConsole("Joystick update error");
  }
}

function collideRectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  try {
    return x1 + w1 > x2 && x2 + w2 > x1 && y1 + h1 > y2 && y2 + h2 > y1;
  } catch (e) {
    console.error('Error in collideRectRect:', e);
    logToConsole("Collision detection error");
    return false;
  }
}
</script>
</body>
</html>
