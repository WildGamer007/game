<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labubu's Rebellion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #222; }
    canvas { border: 2px solid #fff; }
  </style>
</head>
<body>
<script>
let player, enemies, energyOrbs, level, energy, combo, gameState, boss, showHelp, attackTimer;

function setup() {
  createCanvas(800, 600);
  resetGame();
}

function resetGame() {
  player = {
    x: 50, y: 500, w: 40, h: 60, speed: 5, jump: -15, vy: 0, grounded: false,
    attacks: { hand: 10, leg: 15, voice: 20, eye: 25, thunder: 30 },
    currentAttack: 'hand', energy: 50, maxEnergy: 100, health: 100,
    attackActive: false, attackFrame: 0
  };
  enemies = [];
  energyOrbs = [];
  level = 1;
  energy = 0;
  combo = 0;
  gameState = 'start';
  boss = null;
  showHelp = false;
  attackTimer = 0;
  spawnEnemies();
}

function spawnEnemies() {
  enemies = [];
  let enemyTypes = [
    { type: 'human', health: 20, speed: 2, damage: 5, w: 30, h: 50 },
    { type: 'military', health: 40, speed: 1.5, damage: 10, w: 30, h: 50 },
    { type: 'terrorist', health: 30, speed: 2.5, damage: 15, w: 30, h: 50 },
    { type: 'virus', health: 10, speed: 3, damage: 5, w: 15, h: 15 },
    { type: 'missile', health: 15, speed: 4, damage: 20, w: 20, h: 10 }
  ];
  let count = level * 3;
  if (level === 10) {
    boss = {
      x: 700, y: 500, w: 60, h: 80, health: 500, maxHealth: 500, speed: 1,
      attacks: ['electric', 'f16', 'missile', 'covid', 'military', 'terrorist', 'zelensky'],
      attackCooldown: 0, minions: []
    };
    enemies.push(boss);
  } else {
    for (let i = 0; i < count; i++) {
      let type = random(enemyTypes);
      enemies.push({
        x: random(400, 750), y: 500, ...type
      });
    }
  }
}

function draw() {
  background(50);
  if (gameState === 'start') {
    drawStartScreen();
  } else if (gameState === 'playing') {
    updatePlayer();
    updateEnemies();
    updateEnergyOrbs();
    handleCollisions();
    drawUI();
    if (showHelp) drawHelpScreen();
  } else if (gameState === 'gameover') {
    textSize(32);
    fill(255, 0, 0);
    textAlign(CENTER);
    text('Game Over! Press R to Restart', width / 2, height / 2);
  } else if (gameState === 'win') {
    textSize(32);
    fill(0, 255, 0);
    textAlign(CENTER);
    text('You Win! Press R to Restart', width / 2, height / 2);
  }
}

function drawStartScreen() {
  fill(255);
  textAlign(CENTER);
  textSize(32);
  text("Labubu's Rebellion", width / 2, height / 2 - 100);
  textSize(20);
  text("Controls:", width / 2, height / 2 - 50);
  text("Left/Right Arrows: Move", width / 2, height / 2 - 20);
  text("Up Arrow: Jump", width / 2, height / 2 + 10);
  text("Spacebar: Attack (uses energy)", width / 2, height / 2 + 40);
  text("1-5: Select Attack (Hand:10, Leg:15, Voice:20, Eye:25, Thunder:30)", width / 2, height / 2 + 70);
  text("H: Show/Hide Help", width / 2, height / 2 + 100);
  text("R: Restart (on Game Over/Win)", width / 2, height / 2 + 130);
  text("Press S to Start", width / 2, height / 2 + 160);
}

function drawHelpScreen() {
  fill(0, 0, 0, 200);
  rect(100, 100, 600, 400);
  fill(255);
  textAlign(CENTER);
  textSize(24);
  text("Controls", width / 2, 150);
  textSize(18);
  text("Left/Right Arrows: Move", width / 2, 200);
  text("Up Arrow: Jump", width / 2, 230);
  text("Spacebar: Attack (uses energy)", width / 2, 260);
  text("1-5: Select Attack (Hand:10, Leg:15, Voice:20, Eye:25, Thunder:30)", width / 2, 290);
  text("H: Show/Hide Help", width / 2, 320);
  text("R: Restart (on Game Over/Win)", width / 2, 350);
  text("Press H to Close", width / 2, 380);
}

function updatePlayer() {
  // Movement
  if (keyIsDown(LEFT_ARROW)) player.x -= player.speed;
  if (keyIsDown(RIGHT_ARROW)) player.x += player.speed;
  if (keyIsDown(UP_ARROW) && player.grounded) {
    player.vy = player.jump;
    player.grounded = false;
  }
  player.vy += 0.5;
  player.y += player.vy;
  if (player.y >= 500) {
    player.y = 500;
    player.vy = 0;
    player.grounded = true;
  }
  player.x = constrain(player.x, 0, width - player.w);

  // Update attack animation
  if (player.attackActive) {
    player.attackFrame++;
    if (player.attackFrame > 10) {
      player.attackActive = false;
      player.attackFrame = 0;
    }
  }

  // Draw player (Labubu-like with face, hands, legs)
  fill(255, 192, 203); // Pink body
  rect(player.x, player.y, player.w, player.h, 10); // Rounded body
  // Face
  fill(255); // White face patch
  ellipse(player.x + player.w / 2, player.y + 20, 30, 20);
  fill(0); // Eyes
  ellipse(player.x + 12, player.y + 15, 6, 8);
  ellipse(player.x + 28, player.y + 15, 6, 8);
  // Mouth
  noFill();
  stroke(0);
  arc(player.x + player.w / 2, player.y + 25, 10, 5, 0, PI);
  noStroke();
  // Hands
  fill(255, 192, 203);
  if (player.attackActive && player.currentAttack === 'hand') {
    ellipse(player.x + player.w + 10, player.y + 20, 10, 10); // Extended right hand
    ellipse(player.x - 10, player.y + 20, 10, 10); // Left hand
  } else {
    ellipse(player.x + player.w, player.y + 20, 10, 10); // Right hand
    ellipse(player.x, player.y + 20, 10, 10); // Left hand
  }
  // Legs
  if (player.attackActive && player.currentAttack === 'leg') {
    rect(player.x + 5, player.y + player.h, 10, 20); // Extended left leg
    rect(player.x + 25, player.y + player.h, 10, 20); // Extended right leg
  } else {
    rect(player.x + 5, player.y + player.h, 10, 10); // Left leg
    rect(player.x + 25, player.y + player.h, 10, 10); // Right leg
  }
  // Attack effects
  if (player.attackActive) {
    if (player.currentAttack === 'voice') {
      fill(255, 255, 0, 150);
      arc(player.x + player.w / 2, player.y + 25, 50, 30, 0, HALF_PI);
    } else if (player.currentAttack === 'eye') {
      stroke(255, 0, 0);
      line(player.x + 12, player.y + 15, player.x + 62, player.y + 15);
      line(player.x + 28, player.y + 15, player.x + 78, player.y + 15);
      noStroke();
    } else if (player.currentAttack === 'thunder') {
      fill(0, 255, 255, 150);
      ellipse(player.x + player.w / 2, player.y, 60, 60);
    }
  }
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    let e = enemies[i];
    if (e.type === 'missile' || e.type === 'virus') {
      e.x -= e.speed;
    } else {
      if (player.x < e.x) e.x -= e.speed;
      else if (player.x > e.x) e.x += e.speed;
    }
    e.x = constrain(e.x, 0, width - e.w);

    if (e === boss) {
      e.attackCooldown--;
      if (e.attackCooldown <= 0) {
        let attack = random(e.attacks);
        if (attack === 'electric') {
          enemies.push({ x: e.x, y: e.y, w: 50, h: 10, type: 'electric', health: 10, speed: 5, damage: 20 });
        } else if (attack === 'f16') {
          e.minions.push({ x: 800, y: 100, w: 40, h: 20, type: 'f16', health: 30, speed: 3, damage: 15 });
        } else if (attack === 'missile') {
          enemies.push({ x: e.x, y: e.y, w: 20, h: 10, type: 'missile', health: 15, speed: 4, damage: 20 });
        } else if (attack === 'covid') {
          enemies.push({ x: e.x, y: e.y, w: 15, h: 15, type: 'virus', health: 10, speed: 3, damage: 5 });
        } else if (attack === 'military' || attack === 'terrorist') {
          e.minions.push({ x: e.x, y: e.y, w: 30, h: 50, type: attack, health: 30, speed: 2, damage: 10 });
        } else if (attack === 'zelensky') {
          e.minions.push({ x: e.x, y: e.y, w: 30, h: 50, type: 'zelensky', health: 50, speed: 2.5, damage: 15 });
        }
        e.attackCooldown = 60;
      }
      for (let j = e.minions.length - 1; j >= 0; j--) {
        let m = e.minions[j];
        if (m.type === 'f16') m.x -= m.speed;
        else {
          if (player.x < m.x) m.x -= m.speed;
          else if (player.x > m.x) m.x += m.speed;
        }
        fill(m.type === 'f16' ? 150 : m.type === 'zelensky' ? 0 : 100);
        rect(m.x, m.y, m.w, m.h);
      }
    }

    fill(e.type === 'human' ? 200 : e.type === 'military' ? 100 : e.type === 'terrorist' ? 150 : e.type === 'virus' ? 0 : e.type === 'electric' ? 255 : 255);
    rect(e.x, e.y, e.w, e.h);
  }
}

function updateEnergyOrbs() {
  for (let orb of energyOrbs) {
    orb.y += 2;
    fill(255, 255, 0);
    ellipse(orb.x, orb.y, 10, 10);
  }
}

function handleCollisions() {
  if (player.attackActive) {
    let attackRange = 50;
    for (let i = enemies.length - 1; i >= 0; i--) {
      let e = enemies[i];
      if (collideRectRect(player.x + player.w / 2 - attackRange / 2, player.y, attackRange, player.h, e.x, e.y, e.w, e.h)) {
        e.health -= player.attacks[player.currentAttack];
        player.energy -= player.attacks[player.currentAttack];
        combo++;
        if (e.health <= 0) {
          enemies.splice(i, 1);
          energyOrbs.push({ x: e.x, y: e.y });
        }
      }
    }
    if (boss) {
      for (let i = boss.minions.length - 1; i >= 0; i--) {
        let m = boss.minions[i];
        if (collideRectRect(player.x + player.w / 2 - attackRange / 2, player.y, attackRange, player.h, m.x, m.y, m.w, m.h)) {
          m.health -= player.attacks[player.currentAttack];
          player.energy -= player.attacks[player.currentAttack];
          combo++;
          if (m.health <= 0) boss.minions.splice(i, 1);
        }
      }
    }
  }

  for (let e of enemies) {
    if (collideRectRect(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
      player.health -= e.damage;
      if (player.health <= 0) gameState = 'gameover';
    }
  }
  if (boss) {
    for (let m of boss.minions) {
      if (collideRectRect(player.x, player.y, player.w, player.h, m.x, m.y, m.w, m.h)) {
        player.health -= m.damage;
        if (player.health <= 0) gameState = 'gameover';
      }
    }
  }

  for (let i = energyOrbs.length - 1; i >= 0; i--) {
    let orb = energyOrbs[i];
    if (dist(player.x + player.w / 2, player.y + player.h / 2, orb.x, orb.y) < 20) {
      player.energy = min(player.energy + 10, player.maxEnergy);
      energyOrbs.splice(i, 1);
    }
  }

  if (enemies.length === 0 && (!boss || (boss && boss.health <= 0 && boss.minions.length === 0))) {
    if (level < 10) {
      level++;
      spawnEnemies();
    } else {
      gameState = 'win';
    }
  }
}

function drawUI() {
  fill(255);
  textSize(20);
  text(`Health: ${player.health}`, 10, 30);
  text(`Energy: ${player.energy}`, 10, 50);
  text(`Level: ${level}`, 10, 70);
  text(`Combo: ${combo}`, 10, 90);
  text(`Attack: ${player.currentAttack}`, 10, 110);
  text('1:Hand 2:Leg 3:Voice 4:Eye 5:Thunder', 10, 130);
  text('H: Help', 10, 150);
  if (boss) {
    fill(255, 0, 0);
    rect(600, 20, map(boss.health, 0, boss.maxHealth, 0, 180), 20);
    fill(255);
    text('Boss Health', 520, 35);
  }
}

function keyPressed() {
  if (key === 's' && gameState === 'start') {
    gameState = 'playing';
  }
  if (key === 'h' && gameState === 'playing') {
    showHelp = !showHelp;
  }
  if (key === '1') player.currentAttack = 'hand';
  if (key === '2') player.currentAttack = 'leg';
  if (key === '3') player.currentAttack = 'voice';
  if (key === '4') player.currentAttack = 'eye';
  if (key === '5') player.currentAttack = 'thunder';
  if (key === 'r' && (gameState === 'gameover' || gameState === 'win')) resetGame();
  if (keyCode === 32 && gameState === 'playing' && !player.attackActive && player.energy >= player.attacks[player.currentAttack]) {
    player.attackActive = true;
    player.attackFrame = 0;
  }
}

// Collision detection helper
function collideRectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 + w1 > x2 && x2 + w2 > x1 && y1 + h1 > y2 && y2 + h2 > y1;
}
</script>
</body>
</html>
