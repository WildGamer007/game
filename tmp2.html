<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alphabet Breakout</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <style>
    body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
    canvas { display: block; touch-action: none; }
    .controls { position: absolute; bottom: 10px; display: flex; gap: 10px; }
    .mobile-controls { display: none; }
    @media (max-width: 600px) {
      .mobile-controls { display: flex; }
    }
    button { padding: 10px; font-size: 16px; cursor: pointer; }
    .instructions, .settings-form { text-align: center; background: white; padding: 20px; border-radius: 10px; max-width: 600px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .instructions h2, .settings-form h2 { margin: 0 0 10px; font-weight: bold; color: black; }
    .instructions p { margin: 5px 0; font-weight: bold; color: black; }
    .settings-form label { display: block; margin: 10px 0 5px; font-weight: bold; color: black; }
    .settings-form input { padding: 5px; font-size: 16px; width: 200px; }
    .game-over, .win-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: white; padding: 20px; border-radius: 10px; }
    .game-over img, .win-screen img { max-width: 100px; }
  </style>
</head>
<body>
  <div class="controls mobile-controls">
    <button id="leftBtn">Left</button>
    <button id="rightBtn">Right</button>
    <button id="pauseBtn">Pause</button>
    <button id="musicBtn">Music: On</button>
  </div>
  <script>
    let paddle, ball, bricks = [];
    let lives = 3, timeLimit = 5 * 60 * 1000, ballColor = 'red';
    let gameState = 'instructions', currentLetter = 'A', score = 0, multiplier = 1;
    let hitSound, correctSound, backgroundMusic;
    let backgroundImages = [], currentBackground;
    let trophyImage, sadEmojiImage;
    let startTime, elapsedTime = 0, isPaused = false, musicPlaying = true;
    let powerUps = [], particles = [], ballSpeed = 5, highScore = localStorage.getItem('highScore') || 0;
    const brickRows = 3, brickCols = 10;

    function preload() {
      try {
        hitSound = loadSound('bone-crack-1.mp3');
        correctSound = loadSound('button-09a.mp3');
        backgroundMusic = loadSound('war_bg_sound.mp3');
        backgroundImages = [
          loadImage('bg3.png'),
          loadImage('bg4.png'),
          loadImage('bg5.png'),
          loadImage('bg6.png')
        ];
        trophyImage = loadImage('trophy.png');
        sadEmojiImage = loadImage('sad-emoji.png');
      } catch (e) {
        console.warn("Asset loading failed:", e.message);
        hitSound = { play: () => {} };
        correctSound = { play: () => {} };
        backgroundMusic = { loop: () => {}, stop: () => {} };
        backgroundImages = [];
        trophyImage = null;
        sadEmojiImage = null;
      }
    }

    function setup() {
      createCanvas(800, 600);
      paddle = createVector(width / 2 - 50, height - 20);
      paddle.w = 100;
      ball = { pos: createVector(width / 2, height - 40), vel: createVector(0, -ballSpeed), r: 10 };
      initBricks();
      if (musicPlaying) backgroundMusic.loop();
      textAlign(CENTER, CENTER);
      textSize(20);
      currentBackground = backgroundImages.length > 0 ? random(backgroundImages) : null;
      showInstructions();
    }

    function showInstructions() {
      console.log("Showing instructions");
      let instrDiv = createDiv('');
      instrDiv.class('instructions');
      instrDiv.html(`
        <h2>Instructions</h2>
        <p>PC: Use Left/Right arrow keys to move paddle</p>
        <p>Mobile: Use Left/Right buttons to move paddle</p>
        <p>Hit bricks in alphabetical order (A to Z)</p>
        <p>Consecutive hits increase score multiplier</p>
        <p>Catch power-ups for bonuses</p>
        <p>Press P or Pause button to pause</p>
        <p>Press M or Music button to toggle music</p>
        <button id="startBtn">Start Game</button>
      `);
      select('#startBtn').mousePressed(() => {
        console.log("Start button clicked");
        showSettingsForm();
      });
    }

    function showSettingsForm() {
      select('.instructions').remove();
      console.log("Showing settings form");
      let formDiv = createDiv('');
      formDiv.class('settings-form');
      formDiv.html(`
        <h2>Game Settings</h2>
        <label for="gameTime">Game Time (minutes):</label>
        <input type="number" id="gameTime" value="5" min="1" step="0.5">
        <label for="playerLives">Player Lives:</label>
        <input type="number" id="playerLives" value="3" min="1">
        <label for="ballColor">Ball Color:</label>
        <input type="text" id="ballColor" value="red">
        <button id="submitSettings">Submit</button>
      `);
      select('#submitSettings').mousePressed(() => {
        console.log("Submit button clicked");
        startGame();
      });
    }

    function startGame() {
      console.log("startGame called, current gameState:", gameState);
      let gameTimeInput = select('#gameTime');
      let playerLivesInput = select('#playerLives');
      let ballColorInput = select('#ballColor');
      if (!gameTimeInput || !playerLivesInput || !ballColorInput) {
        console.error("Form inputs not found, re-showing settings form");
        showSettingsForm();
        gameState = 'settings';
        return;
      }
      timeLimit = (parseFloat(gameTimeInput.value()) || 5) * 60 * 1000;
      lives = parseInt(playerLivesInput.value()) || 3;
      ballColor = ballColorInput.value() || 'red';
      if (timeLimit < 0) timeLimit = 5 * 60 * 1000;
      if (lives < 1) lives = 3;
      console.log("Settings:", { timeLimit, lives, ballColor });
      select('.settings-form').remove();
      gameState = 'playing';
      startTime = millis();
      score = 0;
      multiplier = 1;
      currentLetter = 'A';
      initBricks();
      resetBall();
      currentBackground = backgroundImages.length > 0 ? random(backgroundImages) : null;
    }

    function initBricks() {
      bricks = [];
      let ranges = [
        ['Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
        ['G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'],
        ['A', 'B', 'C', 'D', 'E', 'F']
      ];
      for (let row = 0; row < brickRows; row++) {
        bricks[row] = [];
        let letters = ranges[row].sort(() => Math.random() - 0.5);
        for (let col = 0; col < brickCols && col < letters.length; col++) {
          bricks[row][col] = {
            x: col * (width / brickCols) + 10,
            y: row * 30 + 50,
            w: width / brickCols - 20,
            h: 20,
            letter: letters[col],
            color: color(random(255), random(255), random(255))
          };
        }
      }
    }

    function draw() {
      if (currentBackground) {
        image(currentBackground, 0, 0, width, height);
      } else {
        background(220);
      }

      if (gameState === 'instructions' || gameState === 'settings') {
        return;
      }

      if (isPaused) {
        fill(0);
        text("Paused", width / 2, height / 2);
        return;
      }

      if (gameState === 'playing') {
        // Paddle movement
        if (keyIsDown(LEFT_ARROW)) paddle.x -= 5;
        if (keyIsDown(RIGHT_ARROW)) paddle.x += 5;
        paddle.x = constrain(paddle.x, 0, width - paddle.w);

        // Update ball speed
        ballSpeed = 5 + Math.min(Math.floor(elapsedTime / 30000 + score / 5), 5);
        ball.vel.setMag(ballSpeed);

        // Draw paddle
        fill(0, 0, 255);
        rect(paddle.x, paddle.y, paddle.w, 10);

        // Draw ball
        fill(ballColor);
        ellipse(ball.pos.x, ball.pos.y, ball.r * 2);

        // Draw bricks
        for (let row of bricks) {
          for (let brick of row) {
            if (brick) {
              fill(brick.color);
              rect(brick.x, brick.y, brick.w, brick.h);
              fill(255);
              text(brick.letter, brick.x + brick.w / 2, brick.y + brick.h / 2);
            }
          }
        }

        // Draw power-ups
        for (let i = powerUps.length - 1; i >= 0; i--) {
          let p = powerUps[i];
          fill(p.type === 'largePaddle' ? 'green' : p.type === 'fastBall' ? 'red' : 'yellow');
          ellipse(p.x, p.y, 20);
          p.y += 3;
          if (p.y > height) powerUps.splice(i, 1);
          if (p.y + 10 > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.w) {
            if (p.type === 'largePaddle') paddle.w = 150;
            else if (p.type === 'fastBall') ballSpeed += 2;
            else if (p.type === 'extraLife') lives++;
            powerUps.splice(i, 1);
          }
        }

        // Draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          fill(255, 255, 0);
          ellipse(p.x, p.y, 5);
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }

        // Update ball
        ball.pos.add(ball.vel);
        if (ball.pos.x - ball.r < 0 || ball.pos.x + ball.r > width) {
          ball.vel.x *= -1;
          hitSound.play();
          multiplier = 1;
        }
        if (ball.pos.y - ball.r < 0) {
          ball.vel.y *= -1;
          hitSound.play();
          multiplier = 1;
        }
        if (ball.pos.y + ball.r > height) {
          lives--;
          if (lives <= 0) {
            gameState = 'gameover';
            if (score * multiplier > highScore) {
              highScore = score * multiplier;
              localStorage.setItem('highScore', highScore);
            }
          } else {
            resetBall();
          }
        }

        // Paddle collision
        if (ball.pos.y + ball.r > paddle.y && ball.pos.x > paddle.x && ball.pos.x < paddle.x + paddle.w) {
          let hitPos = (ball.pos.x - paddle.x) / paddle.w;
          ball.vel.set(10 * (hitPos - 0.5), -ballSpeed);
          hitSound.play();
          multiplier = 1;
        }

        // Brick collision
        for (let row = 0; row < brickRows; row++) {
          for (let col = 0; col < brickCols; col++) {
            let brick = bricks[row][col];
            if (brick && ball.pos.y - ball.r < brick.y + brick.h && ball.pos.y + ball.r > brick.y &&
                ball.pos.x > brick.x && ball.pos.x < brick.x + brick.w) {
              if (brick.letter === currentLetter) {
                bricks[row][col] = null;
                score += multiplier;
                multiplier++;
                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);
                correctSound.play();
                for (let i = 0; i < 10; i++) {
                  particles.push({
                    x: brick.x + brick.w / 2,
                    y: brick.y + brick.h / 2,
                    vx: random(-2, 2),
                    vy: random(-2, 2),
                    life: 20
                  });
                }
                if (random() < 0.1) {
                  powerUps.push({
                    x: brick.x + brick.w / 2,
                    y: brick.y + brick.h,
                    type: random(['largePaddle', 'fastBall', 'extraLife'])
                  });
                }
                ball.vel.y *= -1;
                if (score >= 26) {
                  gameState = 'win';
                  if (score * multiplier > highScore) {
                    highScore = score * multiplier;
                    localStorage.setItem('highScore', highScore);
                  }
                }
              } else {
                hitSound.play();
                ball.vel.y *= -1;
                multiplier = 1;
              }
            }
          }
        }

        // Update elapsed time
        elapsedTime = millis() - startTime;
        if (elapsedTime > timeLimit) {
          gameState = 'gameover';
          if (score * multiplier > highScore) {
            highScore = score * multiplier;
            localStorage.setItem('highScore', highScore);
          }
        }

        // Draw UI
        fill(0);
        text(`Lives: ${lives} | Time: ${Math.floor((timeLimit - elapsedTime) / 1000)}s | Letter: ${currentLetter} | Score: ${score * multiplier} | Multiplier: ${multiplier}x | High Score: ${highScore}`, width / 2, 20);
      }

      if (gameState === 'gameover') {
        fill(0);
        if (sadEmojiImage) {
          image(sadEmojiImage, width / 2 - 50, height / 2 - 100, 100, 100);
        }
        text("Game Over! Try Again?", width / 2, height / 2 + 50);
        text(`High Score: ${highScore}`, width / 2, height / 2 + 80);
        text("Press Enter or Tap to Restart", width / 2, height / 2 + 110);
      } else if (gameState === 'win') {
        fill(0);
        if (trophyImage) {
          image(trophyImage, width / 2 - 50, height / 2 - 100, 100, 100);
        }
        text("Congratulations! You Win!", width / 2, height / 2 + 50);
        text(`High Score: ${highScore}`, width / 2, height / 2 + 80);
        text(`Retry with ${Math.floor(timeLimit / 1000 / 60 * 0.8)} minutes?`, width / 2, height / 2 + 110);
        text("Press Enter or Tap to Restart", width / 2, height / 2 + 140);
      }
    }

    function resetBall() {
      ball.pos.set(width / 2, height - 40);
      ball.vel.set(0, -ballSpeed);
      paddle.w = 100;
    }

    function keyPressed() {
      if (keyCode === ENTER && (gameState === 'instructions' || gameState === 'settings' || gameState === 'gameover' || gameState === 'win')) {
        console.log("Enter pressed, handling state:", gameState);
        if (gameState === 'instructions') {
          select('.instructions').remove();
          showSettingsForm();
          gameState = 'settings';
        } else if (gameState === 'settings') {
          startGame();
        } else if (gameState === 'gameover' || gameState === 'win') {
          if (gameState === 'win') timeLimit *= 0.8;
          select('.game-over')?.remove();
          select('.win-screen')?.remove();
          showSettingsForm();
          gameState = 'settings';
        }
      }
      if (key === 'p' || key === 'P') {
        isPaused = !isPaused;
        console.log("Paused:", isPaused);
      }
      if (key === 'm' || key === 'M') {
        toggleMusic();
      }
    }

    function touchStarted() {
      if (gameState === 'gameover' || gameState === 'win') {
        console.log("Touch started, restarting game");
        if (gameState === 'win') timeLimit *= 0.8;
        select('.game-over')?.remove();
        select('.win-screen')?.remove();
        showSettingsForm();
        gameState = 'settings';
      }
      return false;
    }

    function toggleMusic() {
      musicPlaying = !musicPlaying;
      if (musicPlaying) {
        backgroundMusic.loop();
        document.getElementById('musicBtn').textContent = 'Music: On';
      } else {
        backgroundMusic.stop();
        document.getElementById('musicBtn').textContent = 'Music: Off';
      }
      console.log("Music toggled:", musicPlaying);
    }

    // Mobile controls
    let leftBtn = document.getElementById('leftBtn');
    let rightBtn = document.getElementById('rightBtn');
    if (leftBtn) leftBtn.addEventListener('touchstart', (e) => { paddle.x -= 10; e.preventDefault(); });
    if (rightBtn) rightBtn.addEventListener('touchstart', (e) => { paddle.x += 10; e.preventDefault(); });
    document.getElementById('pauseBtn')?.addEventListener('touchstart', (e) => { isPaused = !isPaused; e.preventDefault(); console.log("Paused:", isPaused); });
    document.getElementById('musicBtn')?.addEventListener('touchstart', (e) => { toggleMusic(); e.preventDefault(); });

    // Prevent default touch behavior on canvas
    document.addEventListener('touchstart', (e) => {
      if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>
